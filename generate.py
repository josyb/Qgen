#  This file is part of the Qgen utility, a Python package for
#  extending the MyHDL package
#
#  Copyright (C) 2014-2015 Josy Boelen
#
#  The Qgen utility is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation; either version 3.0 of the
#  License, or (at your option) any later version.
#
#  This utility is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

'''
Created on  28 Apr 2015
derived from genTcl.py

refactoring everything into classes
splitting a large source file into more manageable pieces

@author: Josy
'''

from __future__ import print_function

import sys
import string
import time


def HwTclHeader(tcltarget, name, version, author, group, elaborate):
    ''' write the header'''

    tcltarget.write(
        '# {}_hw.tcl generated by C-Cam Technologies\n'.format(name))
    # add a timestamp
    tcltarget.write(
        '# {}'.format(time.strftime('UTC: %d/%m/%Y %H:%M\n', time.gmtime(time.time()))))
    tcltarget.write('# Do Not Modify -- or at your own risk :)\n\n')
    # replace _toplevelname_, _author_, _group_
    for line in ['package require -exact sopc 11.0\n',
                 '\n',
                 '#\n',
                 '# module _toplevelname_\n',
                 '#\n',
                 'set_module_property NAME {}\n'.format(name),
                 'set_module_property VERSION {}\n'.format(version),
                 'set_module_property INTERNAL false\n',
                 'set_module_property OPAQUE_ADDRESS_MAP true\n',
                 'set_module_property AUTHOR {}\n'.format(author),
                 'set_module_property DISPLAY_NAME {}\n'.format(name),
                 'set_module_property INSTANTIATE_IN_SYSTEM_MODULE true\n',
                 'set_module_property EDITABLE false\n',
                 'set_module_property ANALYZE_HDL false\n',
                 'set_module_property REPORT_TO_TALKBACK false\n',
                 'set_module_property ALLOW_GREYBOX_GENERATION false\n',
                 'set_module_property GROUP {}\n'.format(group)
                ]:
        tcltarget.write(line)

    if elaborate:
        tcltarget.write('set_module_property ELABORATION_CALLBACK Elaborate\n')

    for line in ['set_module_property GENERATION_CALLBACK Generate\n',
                 '\n',
                 '# +----------------------------------- \n',
                 '# | parameters\n',
                 '# |\n',
                 '\n']:
        tcltarget.write(line)


def HwTclDisplayItems(tcltarget):
    tcltarget.write('# |\n'
                    '# +-----------------------------------'
                    '\n'
                    '\n'
                    '# +-----------------------------------\n'
                    '# | display items\n'
                    '# |\n'
                    '# |\n'
                    '# +-----------------------------------\n'
                    '\n')


def HwTclopenproc(tcltarget, name):
    openproc = ['# +----------------------------------------------------------------\n',
                '# | _proc_ callback\n',
                'proc _proc_ {} {\n']
    for line in openproc:
        line = string.replace(line, '_proc_', name)
        tcltarget.write(line)


def HwTclcloseproc(tcltarget):
    closeproc = ['}\n',
                 '# |\n',
                 '# +-----------------------------------\n\n'
                ]
    for line in closeproc:
        tcltarget.write(line)


def HwTclUtility(tcltarget):
    tcltarget.write('# +----------------------------------------------------------------\n'
                    '# | utility functions\n'
                    'proc log2ceiling { num } {\n'
                    '\tset val 0\n'
                    '\tset i   1\n'
                    '\twhile { $i < $num } {\n'
                    '\t\tset val [ expr $val + 1 ]\n'
                    '\t\tset i   [ expr 1 << $val ]\n'
                    '\t}\n'
                    '\tif { $val == 0 } {\n'
                    '\t\tset val 1\n'
                    '\t}\n'
                    '\treturn $val;\n'
                    '}\n\n'
                   )


def writeHwTcl(generics, connectionpoints, name, version, author, group):
    ''' shortcut to generate the _hw.tcl file needed by Qsys '''

    e1 = ['\tsend_message info "Current Directory: [pwd]"\n',
          '\tset command exec\n',
          # assume python is on the path and _this_.py is in the working
          # directory
          '\tlappend command python [pwd]/_this_.py --QsysElaborate \n',
         ]

    e3start = ['\tset result [eval $command]\n',
               '\t# $result holds what was written to stdout\n',
               '\t# it should look along the line like: lwidth_d 10 lwidth_q 8\n',
               '\t# we don\'t care about \'()[],\' as we will strip them\n',
               '\t#send_message info  "QsysElaborate: OK -> <<<* $result *>>>"\n',
               '\t# now process the returns\n',
               '\t# split the result\n',
               '\tset r [string trim $result  "()[]" ]\n',
               '\t#send_message info "<$r> [llength $r] [string is list $r]"\n',
               '\tset l [list]\n',
               '\tforeach item $r {\n',
               '\t\tlappend l [string trim $item "\',"]\n',
               '\t}\n',
               '\t#send_message info "<<$l>>"\n',
               '\tforeach {name val} $l {\n',
               '\t\tsend_message info  "$name $val"\n',
               '\t}\n',
              ]
#     e3proc = ['\t\tset_interface_property In dataBitsPerSymbol $In_d_width\n']
#     e3end = ['\t} trap NONE errOut {\n',
#              '\t\t# $errOut now holds the message that was written to stderr\n',
#              '\t\t# and everything written to stdout!\n',
#              '\t\tsend_message info  "QsysElaborate: NONE -> <<<! $errOut !>>>"\n',
#              '\t} trap CHILDKILLED {- opts} {\n',
#              '\t\tlassign [dict get $opts -errorcode] -> pid sigName msg\n',
#              '\t\t# process $pid was killed by signal $sigName; message is $msg\n',
#              '\t\tsend_message info  "QsysElaborate: CHILDKILLED -> $sigName $msg"\n',
#              '\t} trap CHILDSTATUS {msg opts} {\n',
#              '\t\tlassign [dict get $opts -errorcode] -> pid code\n',
#              '\t\t# process $pid exited with non-zero exit code $code\n',
#              '\t\t# this happens after a \'raise\' or TaskManager killing of the Python process\n',
#              '\t\t# mag holds both \'stdout\' and \'stderr\' text\n',
#              '\t\tsend_message info  "QsysElaborate: CHILDSTATUS -> $code <<<# $msg #>>>"\n',
#              '\t} trap CHILDSUSP {- opts} {\n',
#              '\t\tlassign [dict get $opts -errorcode] -> pid sigName msg\n',
#              '\t\t# process $pid was suspended by signal $sigName; message is $msg\n',
#              '\t} trap POSIX {- opts} {\n',
#              '\t\tlassign [dict get $opts -errorcode] -> errName msg\n',
#              '\t\t# Some kind of kernel failure; details in $errName and $msg\n',
#              '\t}\n'
#              ]
    g1 = ['\tsend_message info "Current Directory: [pwd]"\n',
          '\tset outdir [get_generation_property OUTPUT_DIRECTORY]\n',
          '\tset outputname [get_generation_property OUTPUT_NAME]\n',
          '\tset targethdl [get_generation_property HDL_LANGUAGE]\n'
          #         '\tset command exec >&@stdout\n',   # redirect the output but we need a console?
          '\tset command exec\n',
          # assume python is on the path and _this_.py is in the working
          # directory
          '\tlappend command python [pwd]/_this_.py -l $targethdl --QsysGenerate \n',
          #             '\tlappend command python [pwd]/_this_.py -v --QsysGenerate \n', # assume python is on the path and _this_.py is in the working directory
          '\tlappend command $outdir $outputname\n',
         ]
    # this one has to be repeated for every generic
    g2 = ['\tlappend command _generic_ [get_parameter_value _generic_ ] \n',  
         ]
    g3 = ['\tsend_message info "Generating using command: $command"\n',
          '\teval $command\n',
          '\tadd_file $outdir/$outputname.vhd {SYNTHESIS SIMULATION}\n',
         ]

    tcltarget = open('%s_hw.tcl' % (name), 'w')
    doelaborate = True if (len(generics.genericlist) > 0) else False
    HwTclHeader(tcltarget, name, version, author, group, elaborate=doelaborate)
    if not generics is None:
        for key, values in generics.genericlist.iteritems():
            values.tclparameter(tcltarget)

    HwTclDisplayItems(tcltarget)

    if not connectionpoints is None:
        for key, values in connectionpoints.connectionpointslist.iteritems():
            values.tclconnectionpoint(tcltarget)

    if generics is not None and len(generics.genericlist) > 0:
        HwTclopenproc(tcltarget, 'Elaborate')
        # if any derived parameters we must ask Python code to elaborate
        derivedparams = False
        for _, value in generics.genericlist.iteritems():
            if hasattr(value, 'derived') and value.derived:
                derivedparams = True
                break

        if derivedparams:
            # collect all Parameters
            for line in e1:
                line = string.replace(line, '_this_', name)
                tcltarget.write(line)
            for key, value in generics.genericlist.iteritems():
#                 if hasattr(value, 'derived') and not value.derived:
                if not value.derived:
                    for line in g2:
                        line = string.replace(line, '_generic_', key)
                        tcltarget.write(line)
            for line in e3start:
                tcltarget.write(line)

        if connectionpoints is not None:
            for key, values in connectionpoints.connectionpointslist.iteritems():
                values.elaborate(tcltarget)

        # handle the 'orphaned' derived generics
        tcltarget.write('\n')
        for key, value in generics.genericlist.iteritems():
            if value.derived and not value.markderived:
                tcltarget.write('\tset_parameter_value {0} [ lindex $l [expr [lsearch $l "{0}"] +1]]] \n'.format( key))

        HwTclcloseproc(tcltarget)

    HwTclopenproc(tcltarget, 'Generate')
    if not generics is None:
        for line in g1:
            line = string.replace(line, '_this_', name)
            tcltarget.write(line)

        for key, value in generics.genericlist.iteritems():
            #             if hasattr(value, 'derived') and not value.derived:
            for line in g2:
                line = string.replace(line, '_generic_', key)
                tcltarget.write(line)

        for line in g3:
            tcltarget.write(line)
    HwTclcloseproc(tcltarget)
    HwTclUtility(tcltarget)
    tcltarget.close()


def updateEntity(target, name):
    vhdsource = open('{}.vhd' .format(target), 'r')
    source = vhdsource.readlines()
    vhdsource.close()
    destination = []
    for line in source:
        if 'entity' in line:
            line = string.replace(line, target, name)
        elif 'architecture' in line and 'of' in line:
            line = string.replace(line, target, name)
        destination.append(line)

    vhddestination = open('{}.vhd' .format(target), 'w')
    vhddestination.writelines(destination)
    vhddestination.close()


if __name__ == '__main__':
    #''' here we add some tests '''

    sys.exit(0)
